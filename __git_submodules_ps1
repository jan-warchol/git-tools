#!/bin/bash

# build upon standard git prompt function
if [[ -e /usr/lib/git-core/git-sh-prompt ]]; then
    source /usr/lib/git-core/git-sh-prompt
elif [[ -e "C:/Program Files/Git/mingw64/share/git/completion/git-prompt.sh" ]]; then
    source "C:/Program Files/Git/mingw64/share/git/completion/git-prompt.sh" 
fi

GIT_PS1_SHOWDIRTYSTATE=1
GIT_PS1_DESCRIBE_STYLE="branch"
GIT_PS1_SHOWUPSTREAM="verbose git"

function submodule_status() {
    module="$1"
    recorded_commit=$(git submodule status --cached "$module" | cut -c2-41)
    if [ "$recorded_commit" = "0000000000000000000000000000000000000000" ]; then
        echo -n " $module: CONFLICT"
    else
        cd "$module"
        behind_count=$(git rev-list --count ..$recorded_commit)
        ahead_count=$(git rev-list --count $recorded_commit..)
        [ $behind_count -ne 0 ] && behind="-${behind_count}"
        [ $ahead_count -ne 0 ] && ahead="+${ahead_count}"
        [ -n "$behind$ahead" ] && separator=" "

        __git_ps1 "${module}${separator}${ahead}${behind}: %s" | sed 's|remotes/||'
        cd ..
    fi
}

if [ -e './.gitmodules' ]; then
    echo -n "["
    # iterate over initialized submodules (handles whitespace in submodule paths)
    git submodule foreach 'echo $sm_path' | grep -v '^Entering' | while read -r module; do
        submodule_status "$module"
    done
    echo -n "]"
fi

